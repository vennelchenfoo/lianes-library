# 3) CRUD - Borrowers

# Create Borrower
# params = parameter dictionary
# .mappings() = converts a tuple into a dictionary
# .one() = show me exactly ONE row. (every borrower hast only on id) 

def create_borrower(name, email=None, phone=None, address=None):
    """
    CREATE:
    Insert a new borrower.
    Default status = 'ACTIVE'.
    Returns the inserted borrower row as dict.
    """
    if not name:
        raise ValueError('Name is required for a borrower.')
    
    engine = get_engine()
    insert_sql = text("""
        INSERT INTO borrowers (name, email, phone, address)
        VALUES (:name, :email, :phone, :address)
    """)

    params = {
        "name": name,
        "email": email,
        "phone": phone,
        "address": address,
    }

    with engine.begin() as conn:
        result = conn.execute(insert_sql, params)
        # get the borrower_id generated by the database for new record:
        try:
            borrower_id = result.inserted_primary_key[0]
        except Exception:
            # if it's not working (MySQL):
            borrower_id = result.lastrowid
        
        row = conn.execute(
            text(SELECT * FROM borrowers WHERE borrower_id = :id),
            {"id": borrowers_id}
        ).mappings().one()

    # returning borrower record into a clean dict:
    return dict(row)

# Get Borrower By ID
# SELECT * FROM borrowers WHERE borrower_id = ... => output dict OR None

def get_borrower_by_id(borrower_id):
    """
    READ (single):
    Get one borrower by id.
    Returns dict or None.
    """
engine = get_engine()
sql = text("SELECT * FROM borrowers WHERE borrower_id = :id")

with engine.connect as conn:
    row = conn.execute(sql, {"id": borrower_id}).mappings().one_or_none()

return dict(row) if row is not None else None

# Get Borrowers
# optional name LIKE '%...%', optional status = 'ACTIVE', 
# LIMIT :limit -> output list from dicts

def get_borrowers(name=None, status=None, limit=100):
    """
    READ (list):
    List borrowers with optional filters:
    - name: partial match (LIKE)
    - status: 'ACTIVE' / 'INACTIVE'
    - limit: max number of results
    Returns list[dict].
    """
    engine = get_engine()

    # Basic-Query
    query = "SELECT * FROM borrowers WHERE 1 = 1"
    params = {}

    if name: 
        query += " AND name LIKE :name"
        params["name"] = f"%{name}"

    if status:
        query += " AND status = :status"
        params["status"] = status

    query += " ORDER BY date_joined DESC LIMIT :limit"
    params["limit"] = int(limit)

    sql = text(query)

    with engine.connect() as conn:
        row = conn.execute(sql, params).mappings().all()

    return [dict(r) for r in rows]


# Update Borrower Contact
# update only fields that we pass (email, phone, address).
# If nothing is going to passed -> False.
# After the update row will be put back.

def update_borrower_contact(borrower_id, email=None, phone=None, address=None):
    """
    UPDATE (partial):
    Update only provided contact fields (email, phone, address).
    Returns updated borrower as a dict.
    """
    fields = []
    params = {"id": borrower_id}

    if email in not None:
        fields.append("email = :email")
        params["email"] = email

    if phone is not None:
        fields.append("phone = :phone")
        params["phone"] = phone

    if address is not None:
        fields.append("address = :address")
        params["address"] = address

    if not fields:
        raise ValueError("No contact fields provided to update.")
    
    set_clause = ", ".join(fields)
    sql = text(f"UPDATE borrowers SET {set_clause} WHERE borrower_id = :id")

    engine = get_engine()
    with engine.begin() as conn:
        conn.execute(sql, params)
        row = conn.execute(
            text("SELECT * FROM borrowers WHERE borrower_id = :id")
            {"id": borrower_id}
        ).mappings().one()
    
    return dict(row)

# Set Borrower Status
# validates that new_status in {ACTIVE, INACTIVE} is.
# -> update the fields and returns rows

def set_borrower_status(borrower_id, new_status):
    """
    UPDATE (status):
    Set status to 'ACTIVE' or 'INACTIVE'.
    Returns updated borrower dict.
    """
    allowed = {"ACTIVE", "INACTIVE"}
    if new_status not in allowed:
        raise ValueError(f"Invalid status '{new_status}'. Allowed: {allowed}")
    
    sql = text("""
        UPDATE borrowers
               SET status = :status
               WHERE borrower_id = :id
    """)

    engine = get_engine()
    with engine.begin() as conn:
        conn.execute(sql, {"status": new_status, "id": borrower_id})
        row = conn.execute(
            text(f"SELECT * FROM borrowers WITH borrower_id"),
            {"id": borrower_id}
        ).mappings().one()

    return dict(row)


# DELETE Borrower
# if: status = 'INACTIVE'
# by hard_delete=True -> 100% delet.

def delete_borrower(borrower_id, hard_delete=False):
    """
    DELETE / logical DELETE:
    - if hard_delete=False (default): set status = 'INACTIVE' (logical delete).
    - if hard_delete=True: permanently remove from the row.
    Returns True if something was changed.
    """
    engine = get_engine()

    if hard_delete:
        sql = text("DELETE FROM borrowers WHERE borrower_id = :id")
        with engine.begin() as conn:
            result = conn.execute(sql, {"id": borrower_id})
        return result.rowcount > 0
    
# logical delete -> set to INACTIVE
    sql = ("""
           UPDATE borrowers
           SET status = 'INACTIVE'
           WHERE borrower_id = :id
    """)
    with engine.begin() as conn:
        result = conn.execute(sql, {"id": borrower_id})
    return reslut.rowcount > 0